Tree

â€¢ Similar to linked list
â€¢ But each node can point to multiple nodes
â€¢ Root: no parents
â€¢ Edge: link from parent to child
â€¢ Leaf node: no children
â€¢ Siblings: children of the same parent


Level, depth and height

â€¢ Depth of a node: path-length from the root
â€¢ Height of a tree: path-length from the root to the
deepest node
â€¢ Size: total number of nodes in a tree

Binary Tree

â€¢ Each node has â‰¤ 2 children
â€¢ Proper binary tree Exactly 2 children Or, no children
â€¢ Full binary tree Exactly 2 children and, all leaf nodes are at same level


Tree: implementation
class Node:
  def __init__(self,item,left=None,right=None):
    self.item=item
    self.left=left
    self.right=right

n1 =Node(5)
n2 =Node(7)
root =Node(10, n1, n2)


Tree: operations
  â€¢ Basic operations
    â€¢ Insertion
    â€¢ Deletion
    â€¢ Traversal
    â€¢ Search
  â€¢ Auxiliary operations //ë³´ì¡°ì
    â€¢ Size of the tree
    â€¢ Height of the tree


Traversal
  â€¢ Depth First Traversal
    â€¢ Preorder: self-left-right
    â€¢ Inorder: left-self-right
    â€¢ Postorder: left-right-self
  â€¢ Breadth First Traversal
    â€¢ Level Order Traversal
  
1. Preorder Traversal
â€¢ Self-left-right
â€¢ Each node is processed before (pre) its subtrees

def preorder(node):
  if node is not None:
    print(node.item)
    preorder(node.left)
    preorder(node.right)

Preorder: 1 2 4 5 3 6 7


2. Inorder Traversal
â€¢ Left-self-right
â€¢ Each node is processed (in) between its subtrees

Inorder: 4 2 5 1 6 3 7

3. Level Order Traversal(ë ˆë²¨ìˆœíšŒ ì•Œê³ ë¦¬ì¦˜)
â€¢ Breadth First Traversal
â€¢ While traversing a level h,
â€¢ Keep track of nodes at the next level (h+1)
â€¢ Go to the next level and visit all the nodes tracked nodes
â€¢ Repeat this until all levels are completed

íŠ¸ë¦¬ì—ì„œ ê° ë ˆë²¨ì˜ ë…¸ë“œë¥¼ ìˆœì„œëŒ€ë¡œ ë°©ë¬¸í•˜ëŠ” ë°©ë²•, íë¥¼ ì´ìš©í•˜ì—¬ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.
1. ë£¨íŠ¸ ë…¸ë“œë¥¼ íì— ì¶”ê°€
2. íì—ì„œ ë…¸ë“œë¥¼ í•˜ë‚˜ ì œê±°, í˜„ì¬ ë…¸ë“œë¡œ ì„¤ì •
3. í˜„ì¬ ë…¸ë“œë¥¼ ë°©ë¬¸
4. í˜„ì¬ ë…¸ë“œì˜ ìì‹ë“¤ì„ íì— ì¶”ê°€


ì‹œê°„ ë³µì¡ë„: ğ‘‚(ğ‘›) -> íŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œë¥¼ í•œ ë²ˆì”© ë°©ë¬¸í•˜ê¸° ë•Œë¬¸
def level_order(root):
  Q=Queue()
  if root in None:
    return
  Q.enqueue(root)
  while not Q.is_empty():
    temp =Q.dequeue()
    print(temp.item)
    if temp.left is not None:
      Q.enqueue(temp.left)
    if temp.right is not None:
      Q.enqueue(temp.right)


Level Order: 1 2 3 4 5 6 7

