Breadth-First Search
â€¢ Breadth-first search (BFS) is another general technique for traversing a graph

ì˜ˆì‹œì—ëŒ€í•œ ê³µë¶€ í•„ìš”
â€¢ A BFS traversal of a graph G
â€¢ Visits all the vertices and edges of G
â€¢ Determines whether G is connected
â€¢ Computes the connected components of G
â€¢ Computes a spanning forest of G

â€¢ BFS on a graph with nvertices and medges takes O(n + m) time
â€¢ BFS can be further extended to solve other graph problems
  â€¢ Find and report a path between two given vertices
  â€¢ Can label each vertex by the length of a shortest path (in terms of # of edges) from the start vertex s
  â€¢ Find a simple cycle, if there is one


BFS Algorithm(ë„ˆë¹„ ìš°ì„  íƒ)
â€¢ The algorithm uses a mechanism for setting and getting â€œlabelsâ€ of vertices and edges


Algorithm BFS(G)
Input : graph G
Output : labeling of the edges and partition of the vertices of G

for all u in G.vertices() 
  u.setLabel(UNEXPLORED)
for all e in G.edges()
  e.setLabel(UNEXPLORED)
for all v in G.vertices()
if v.getLabel() = UNEXPLORED
  BFS(G, v)

ëª¨ë“  ì •ì ê³¼ ê°„ì„ ë“¤ì„ ë¯¸ë°©ë¬¸ ìƒíƒœë¡œ ì„¤ì •í•´ë‘”ë‹¤.
ëª¨ë“  ì •ì ì— ëŒ€í•´ bfsë¥¼ ìˆ˜í–‰í•œë‹¤.

Algorithm BFS(G, s)

L0 <- new empty sequence //ë¹ˆ ê³µê°„ ìƒì„±
L0.insertBack(s) //ì‹œì‘ ì •ì  së¥¼ ì‹œí€¸ìŠ¤ ë’¤ìª½ì— ì¶”ê°€
s.setLabel(VISITED) // ì¶”ê°€í–ˆìœ¼ë‹ˆ ë°©ë¬¸ë¨ ìƒíƒœë¡œ ë³€ê²½í•´ë‘”ë‹¤.
i <- 0 //ì´ˆê¸°í™”
while  Li.empty() // ë°˜ë³µì ìœ¼ë¡œ ìˆ˜í–‰
Li +1 <- new empty sequence //ìƒˆë¡œìš´ ë¹ˆ ì‹œí€¸ìŠ¤ë¥¼ ì¶”ê°€
for all v in Li.elements() // ëª¨ë“  ì •ì ì— ëŒ€í•´ ë°˜ë³µ ìˆ˜í–‰
  for all e in v.incidentEdges()
    if e.getLabel() = UNEXPLORED
      w <- e.opposite(v)
      if w.getLabel() = UNEXPLORED
        e.setLabel(DISCOVERY)
        w.setLabel(VISITED)
        Li +1.insertBack(w)
      else
        e.setLabel(CROSS)
i <- i +1


ì´ëŸ° ë°©ì‹ìœ¼ë¡œ bfsëŠ” ì‹œì‘ ì •ì ì„ ê¸°ì¤€ìœ¼ë¡œ ë„ˆë¹„ ìš°ì„  ê·¸ë˜í”„ë¥¼ íƒìƒ‰í•œë‹¤.
ê°„ì„ , ì •ì ì„ ë ˆì´ë¸”ë§ í•  ìˆ˜ ìˆê³  ê·¸ë˜í”„ë¥¼ ë¶„í• í•  ìˆ˜ ìˆë‹¤.
ì´ ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ íŠ¹ì§•ì€ ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ê°€ê¹Œìš´ ì •ì ì„ ìš°ì„ ì ìœ¼ë¡œ íƒìƒ‰í•˜ê³  íƒìƒ‰í•œ ê²½ë¡œë¥¼ íì— ì €ì¥í•˜ì—¬ ë„ˆë¹„ ìš°ì„ ìœ¼ë¡œ íƒìƒ‰í•˜ëŠ” ê²ƒì´ë‹¤.


Li+1.insertBack(w) ì„¤ëª…
BFS ì•Œê³ ë¦¬ì¦˜ì—ì„œ LiëŠ” í˜„ì¬ íƒìƒ‰í•  ì •ì ë“¤ì´ ì €ì¥ëœ í(ë˜ëŠ” ì‹œí€€ìŠ¤)
BFSëŠ” ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ, ê°™ì€ ê¹Šì´ì˜ ëª¨ë“  ì •ì ë“¤ì„ í•œ ë²ˆì— ì²˜ë¦¬í•œ í›„ ë‹¤ìŒ ê¹Šì´ì˜ ì •ì ë“¤ì„ ì²˜ë¦¬í•´ì•¼ í•œë‹¤. 
ë”°ë¼ì„œ Li+1ì€ ë‹¤ìŒ íƒìƒ‰ ë‹¨ê³„ì—ì„œ ì²˜ë¦¬í•  ë‹¤ìŒ ê¹Šì´ì˜ ì •ì ë“¤ì„ ì €ì¥í•˜ê¸° ìœ„í•œ ìƒˆë¡œìš´ ì‹œí€€ìŠ¤ì´ë‹¤. 
ì´ ì‹œí€€ìŠ¤ì—ëŠ” í˜„ì¬ ê¹Šì´ì—ì„œ ë°œê²¬ëœ ëª¨ë“  ì •ì ë“¤ì˜ ì¸ì ‘ ì •ì ë“¤ì´ ì¶”ê°€ë©ë‹ˆë‹¤.

i <- i + 1 ì„¤ëª…
ë°˜ë³µë¬¸ ë‚´ì—ì„œ iëŠ” í˜„ì¬ê¹Œì§€ íƒìƒ‰í•œ ê¹Šì´ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë³€ìˆ˜
BFS ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” í•œ ë²ˆì˜ ë°˜ë³µì´ í•œ ê¹Šì´ì˜ ëª¨ë“  ì •ì ë“¤ì„ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ì˜ë¯¸
ì¦‰, Liì— ìˆëŠ” ëª¨ë“  ì •ì ë“¤ì„ ì²˜ë¦¬í•˜ê³  ë‚˜ë©´, ë‹¤ìŒ ê¹Šì´ì˜ ì •ì ë“¤ì„ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ Li+1ì„ ìƒˆë¡­ê²Œ ì´ˆê¸°í™”
ì´í›„ì—ëŠ” ië¥¼ 1 ì¦ê°€ì‹œì¼œì„œ ë‹¤ìŒ ê¹Šì´ë¡œ ë„˜ì–´ê°ì„ ë‚˜íƒ€ë‚¸ë‹¤.


Properties

Notation Gs
: connected component of s

Property 1
BFS(G, s) visits all the vertices and edges of Gs

Property 2
The discovery edges labeled by BFS(G, s) form a spanning tree Ts of Gs
-> BFS(G, s)ì— ì˜í•´ ë ˆì´ë¸”ë§ëœ Discovery ê°„ì„ ì€ Gsì˜ Spanning Tree Tsë¥¼ í˜•ì„±í•©ë‹ˆë‹¤
BFS ì‹¤í–‰ ì¤‘ "DISCOVERY"ë¡œ ë ˆì´ë¸”ë§ëœ ê°„ì„ ë“¤ì€ Gsì˜ Spanning Tree Tsë¥¼ í˜•ì„±
Gsì˜ Spanning TreeëŠ” Gsì˜ ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ë©° íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ê°–ìŠµë‹ˆë‹¤ (ì¦‰, ë¹„ìˆœí™˜ì ì´ê³  ì—°ê²°ëœ êµ¬ì¡°)

Property 3
For each vertex v in Li 
  â€¢ The path of Ts from s to v has i edges 
-> Tsì—ì„œ sì—ì„œ vë¡œ ê°€ëŠ” ê²½ë¡œëŠ” iê°œì˜ ê°„ì„ ì„ ê°€ì§‘ë‹ˆë‹¤
ì´ëŠ” Spanning Tree Tsì—ì„œ ì‹œì‘ ì •ì  sì—ì„œ Liì˜ ê° ì •ì  vë¡œ ê°€ëŠ” ìµœë‹¨ ê²½ë¡œê°€ iê°œì˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŒì„ ì˜ë¯¸
  â€¢ Every path from s to v in Gs has at least i edges (i.e., find a shortest path)
-> Gsì—ì„œ sì—ì„œ vë¡œ ê°€ëŠ” ëª¨ë“  ê²½ë¡œëŠ” ì ì–´ë„ iê°œì˜ ê°„ì„ ì„ ê°€ì§‘ë‹ˆë‹¤ (ì¦‰, ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤)
ì´ ì†ì„±ì€ BFSê°€ ì‹œì‘ ì •ì  sì—ì„œ Gs ë‚´ì˜ ëª¨ë“  ë‹¤ë¥¸ ì •ì  vë¡œì˜ ìµœë‹¨ ê²½ë¡œ(ê°„ì„ ì˜ ìµœì†Œ ìˆ˜)ë¥¼ ì°¾ëŠ”ë‹¤ëŠ” ì ì„ ë³´ì¥í•©ë‹ˆë‹¤.

ì‰½ê²Œë§í•´
i=0: ì‹œì‘ ì •ì  s ìì²´ì´ë¯€ë¡œ, sì—ì„œ së¡œì˜ ê²½ë¡œëŠ” 0ê°œì˜ ê°„ì„ ì„ ê°€ì§‘ë‹ˆë‹¤.
i=1: sì—ì„œ Tsì˜ ë‹¤ìŒ ë ˆë²¨ì—ì„œ ë°œê²¬ëœ ì •ì ë“¤ê¹Œì§€ì˜ ê²½ë¡œëŠ” 1ê°œì˜ ê°„ì„ ì„ ê°€ì§‘ë‹ˆë‹¤.
i=2: sì—ì„œ Ts ì˜ ë‘ ë²ˆì§¸ ë ˆë²¨ì—ì„œ ë°œê²¬ëœ ì •ì ë“¤ê¹Œì§€ì˜ ê²½ë¡œëŠ” 2ê°œì˜ ê°„ì„ ì„ ê°€ì§‘ë‹ˆë‹¤.


Analysis(dfsì™€ ê°™ì€)
â€¢ Setting/getting a vertex/edge label takes O(1) time
â€¢ Each vertex is labeled twice
  â€¢ once as UNEXPLORED
  â€¢ once as VISITED
â€¢ Each edge is labeled twice
  â€¢ once as UNEXPLORED
  â€¢ once as DISCOVERY or CROSS
â€¢ Each vertex is inserted once into a sequence Li
â€¢ Method incidentEdges is called once for each vertex // incidentEdgesë©”ì†Œë“œëŠ” ê° ì •ì ë‹¹ í•œë²ˆ í˜¸ì¶œëœë‹¤.
â€¢ BFS runs in O(n + m) time provided the graph is represented by the adjacency list structure
â€¢ Recall that ì‹œê·¸ë§ˆv deg(v) = 2m

Applications(í•´ê²°í•  ìˆ˜ ìˆëŠ” ë¬¸ì œë“¤)
â€¢ Using the template method pattern, we can specialize the BFS traversal of a graph G to solve the following problems in O(n + m) time
â€¢ Compute the connected components of G // ê·¸ë˜í”„ì˜ ì—°ê²°ìš”ì†Œ ê³„ì‚°
â€¢ Compute a spanning forest of G // spanning forest ê³„ì‚°
â€¢ Find a simple cycle in G, or report that Gis a forest // ê°„ë‹¨í•œ ì‚¬ì´í´ ì°¾ê¸° ë˜ëŠ” forest ì—¬ë¶€ë³´ê³ 
â€¢ Given two vertices of G, find a path in G between them with the minimum number of edges, or report that no such path exists
// ë‘ì •ì  ì‚¬ì´ ìµœì†Œ ê°„ì„  ê²½ë¡œ ì°¾ê¸°



DFS vs. BFS
Spanning forest, connected components, paths, cycles : both
Shortest paths : bfs only
Biconnected components: dfs only

* Biconnected components (ì´ì¤‘ì—°ê²°ìš”)
- Connected
- Even after removing anyvertex the graph remainsconnected
-> ê·¸ë˜í”„ì—ì„œ ì‚­ì œí•˜ë”ë¼ë„ ì—¬ì „íˆ ì—°ê²°ëœ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ì„œë¸Œê·¸ë˜í”„
   ì¦‰, ì´ ì„œë¸Œê·¸ë˜í”„ëŠ” ì ì–´ë„ ë‘ ê°œì˜ ì—°ê²°ëœ ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” êµ¬ì„± ìš”ì†Œì´ë‹¤.
dfsëŠ” ê° ì •ì ì„ í•œë²ˆ ë°©ë¬¸í•˜ê³  ê°„ì„ ë„ í•œë²ˆì”© ë°©ë¬¸í•˜ê¸° ë•Œë¬¸ì— ê° ì •ì ì— ëŒ€í•´ ì‚¬ì´í´ì„ ì°¾ì„ ìˆ˜ ìˆë‹¤.
ì´ ì •ë³´ë¥¼ í™œìš©í•˜ì—¬ Biconnected componentsë„ ì•Œì•„ë‚¼ ìˆ˜ ìˆë‹¤.
ê·¸ëŸ¬ë‚˜ ì¶”ê°€ì ìœ¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì´ í•„ìš”í•˜ë‹¤.

1. DFS Tree: DFS ì‹¤í–‰ ì¤‘ ê° ê°„ì„ ì˜ ë¶„ë¥˜(Discovery, Back ë“±)ë¥¼ ê¸°ë¡í•œë‹¤. ì´ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ ê° ì •ì ì˜ ê¹Šì´(DFS ìˆœì„œ)ë¥¼ ê¸°ë¡í•  ìˆ˜ ìˆë‹¤.
2. Low Values ê³„ì‚°: ê° ì •ì ì—ì„œ ìì‹ ë…¸ë“œë¡œ ì´ì–´ì§€ëŠ” Back Edgeì— ëŒ€í•œ Low Valueë¥¼ ê³„ì‚°í•œë‹¤. ì´ë¥¼ í†µí•´ ê° ì •ì ì—ì„œ ë¶€ëª¨ ë…¸ë“œë¥¼ í†µí•´ ê°ˆ ìˆ˜ ìˆëŠ” ê°€ì¥ ë†’ì€ ì •ì ì˜ ê¹Šì´ë¥¼ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
3. Bridge Edge ê²€ì‚¬: ê°„ì„ ì´ Bridge Edge(ë‹¨ì ˆ ê°„ì„ )ì¸ì§€ í™•ì¸í•˜ì—¬, Bridge Edgeê°€ ì•„ë‹Œ ê²½ìš° Biconnected Componentë¥¼ í˜•ì„±ë‹¤.


*1,2ë²ˆì„ í†µí•´ì„œ ë‹¨ì ˆìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ìˆê¸´í•œë°, êµìˆ˜ë‹˜ì´ ìš°ë¦¬ì—ê²Œ ì´ì •ë„ ê¹Œì§€ ìš”êµ¬í• ê¹Œ ì‹¶ì€ ë§ˆìŒì´ ë“¤ê¸´í•œë‹¤.


DFS vs. BFS (cont.)
Back edge (v,w)
â€¢ w is an ancestor of v in the tree of discovery edges

Cross edge (v,w)
â€¢ w is in the same level as vor in the next level

ê¹Šì´ ìš°ì„  íƒìƒ‰ (DFS)
ê¹Šì´ ìš°ì„  íƒìƒ‰ì€ íŠ¹ì •í•œ ì‹œì‘ ì •ì ì—ì„œ ì¶œë°œí•˜ì—¬ ê°€ëŠ¥í•œ í•œ ë©€ë¦¬ê¹Œì§€ íƒìƒ‰ì„ ì§„í–‰í•œ í›„, ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ì„ ë•Œ ë˜ëŒì•„ì˜¤ëŠ” ë°©ì‹ì˜ ê·¸ë˜í”„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜
íŠ¸ë¦¬ ê°„ì„  (Tree Edge): ê°„ì„  (v, w)ê°€ íŠ¸ë¦¬ ê°„ì„ ì¸ ê²½ìš°, ì •ì  wê°€ ì²˜ìŒ ë°œê²¬ë˜ê³ , ì •ì  vì˜ ìì‹ ë…¸ë“œì¸ ê²½ìš°
ë°± ì—£ì§€ (Back Edge): ê°„ì„  (v, w)ê°€ ë°± ì—£ì§€ì¸ ê²½ìš°, ì •ì  wê°€ ì •ì  vì˜ ì¡°ìƒì¸ ê²½ìš°
DFS íƒìƒ‰ ì¤‘ í˜„ì¬ ì •ì ì—ì„œ ë” ì´ìƒ íƒìƒ‰í•  ìˆ˜ ì—†ì–´ì„œ ë˜ëŒì•„ê°€ë©´ì„œ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

ë„ˆë¹„ ìš°ì„  íƒìƒ‰ (BFS)
ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì€ ì‹œì‘ ì •ì ì—ì„œ ê°€ê¹Œìš´ ì •ì ë¶€í„° ì°¨ë¡€ëŒ€ë¡œ íƒìƒ‰í•˜ëŠ” ê·¸ë˜í”„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜
ìˆ˜í‰ ê°„ì„  (Cross Edge): ê°„ì„  (v, w)ê°€ ìˆ˜í‰ ê°„ì„ ì¸ ê²½ìš°, ì •ì  wê°€ ì •ì  vì™€ ê°™ì€ ë ˆë²¨ì— ìˆê±°ë‚˜ ë‹¤ìŒ ë ˆë²¨ì— ìˆì„ ìˆ˜ ìˆë‹¤. 
BFSì—ì„œëŠ” ê°™ì€ ë ˆë²¨ì— ìˆëŠ” ì •ì ë“¤ì„ ëª¨ë‘ ë°©ë¬¸í•œ í›„ì— ë‹¤ìŒ ë ˆë²¨ì˜ ì •ì ë“¤ì„ ë°©ë¬¸ë‹¤.


ì˜ˆì‹œ
   A
 / | \
B  C  D
|     |
E     F

íŠ¸ë¦¬ ê°„ì„  (Tree Edge): DFS íƒìƒ‰ ê³¼ì •ì—ì„œ ì •ì  Aì—ì„œ ì‹œì‘í•˜ì—¬ B, Eë¡œ ì§„í–‰í•  ë•Œ, (A, B), (B, E)ì™€ ê°™ì´ ë°œìƒí•˜ëŠ” ê°„ì„ 
Bì™€ EëŠ” Aì˜ ìì†ì´ê³ , ì²˜ìŒ ë°œê²¬ëœ ì •ì ë“¤
ë°± ì—£ì§€ (Back Edge): DFS íƒìƒ‰ ì¤‘ì— ì •ì ì„ ë°©ë¬¸í•˜ê³ , ê·¸ ì •ì ì—ì„œ ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ì–´ ë˜ëŒì•„ê°ˆ ë•Œ ë°œìƒí•˜ëŠ” ê°„ì„ 
ì˜ˆë¥¼ ë“¤ì–´, A â†’ B â†’ Eì—ì„œ E â†’ Bë¡œ ë˜ëŒì•„ê°€ëŠ” ê²½ìš° (E, B)ì™€ ê°™ì€ ê°„ì„ ì´ ë°± ì—£ì§€ê°€ ëœë‹¤.

ìˆ˜í‰ ê°„ì„  (Cross Edge): BFS íƒìƒ‰ ì¤‘ ê°™ì€ ë ˆë²¨ì— ìˆëŠ” ì •ì ë“¤ ì‚¬ì´ì—ì„œ ë°œìƒí•˜ëŠ” ê°„ì„ . 
ì˜ˆë¥¼ ë“¤ì–´, Aì—ì„œ ì‹œì‘í•˜ì—¬ B, C, Dë¥¼ íƒìƒ‰í•  ë•Œ, (B, C), (B, D)ì™€ ê°™ì€ ê°„ì„ ì€ ìˆ˜í‰ ê°„ì„ 
BFSëŠ” í•œ ë ˆë²¨ì˜ ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•œ í›„ ë‹¤ìŒ ë ˆë²¨ì˜ ì •ì ë“¤ì„ ë°©ë¬¸í•˜ê¸° ë•Œë¬¸ì—, ê°™ì€ ë ˆë²¨ì˜ ì •ì ë“¤ ì‚¬ì´ì—ëŠ” ìˆ˜í‰ ê°„ì„ ì´ ë°œìƒ.


Shortest Paths

Weighted Graphs
â€¢ In a weighted graph, each edge has an associated numerical value, called the weight of the edge
â€¢ Edge weights may represent, distances, costs, etc.
â€¢ Example:
  â€¢ In a flight route graph, the weight of an edge represents the distance in miles between the endpoint airports


Shortest Paths

â€¢ Given a weighted graph and two vertices u and v, we want to find a path of minimum total weight between u and v.
  â€¢ Length of a path is the sum of the weights of its edges.
â€¢ Example:
  â€¢ Shortest path between Providence and Honolulu
â€¢ Applications
  â€¢ Internet packet routing
  â€¢ Flight reservations
  â€¢ Driving directions


Shortest Path Properties

Property 1:
A subpath of a shortest path is itself a shortest path
// ìµœë‹¨ ê²½ë¡œì˜ ë¶€ë¶„ ê²½ë¡œë„ ìµœë‹¨ ê²½ë¡œì´ë‹¤.
ì •ì  Aì—ì„œ ì •ì  Bê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œê°€ ì¡´ì¬í•  ë•Œ, ì´ ê²½ë¡œì˜ ì–´ë–¤ ë¶€ë¶„ ê²½ë¡œë„ Aì™€ B ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œì´ë‹¤.
ë¶€ë¶„ ê²½ë¡œê°€ ë” ì§§ì€ ê²½ë¡œë³´ë‹¤ ê¸¸ë‹¤ë©´ ì´ˆê¸° ê°€ì •(ë” ê¸´ ê²½ë¡œê°€ ìµœë‹¨ ê²½ë¡œ)ì„ ë¶€ì •í•˜ê²Œ ëœë‹¤.
ìµœë‹¨ ê²½ë¡œì˜ ë¶€ë¶„ ê²½ë¡œëŠ” ì–´ëŠ ê²½ìš°ë¼ë„ ì—­ì‹œ ìµœë‹¨ ê²½ë¡œì´ë‹¤.
*ì •ì  Aì—ì„œ ì •ì  Bë¡œ ê°€ëŠ” ê²½ë¡œê°€ A â†’ C â†’ D â†’ Bë¼ê³  í•˜ë©´, ì—¬ê¸°ì„œ A â†’ C ë˜ëŠ” C â†’ D ë˜ëŠ” D â†’ Bì™€ ê°™ì€ ë¶€ë¶„ë“¤ì´ ë¶€ë¶„ ê²½ë¡œ

Property 2:
There is a tree of shortest paths from a start vertex to all the other vertices
//ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ëª¨ë“  ë‹¤ë¥¸ ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œëŠ” ìµœë‹¨ ê²½ë¡œ íŠ¸ë¦¬ë¥¼ í˜•ì„±í•œë‹¤.
*Shortest Path Tree, SPT

Example:
Tree of shortest paths from Providence (PVD)


Our goal and Initial Ideas
â€¢ Goal
  â€¢ Given a source vertex s, compute the shortest paths to all other vertices
â€¢ Initial Ideas
  â€¢ Compute all the paths from the source s to other vertices
  â€¢ Take the minimums
  â€¢ How much complexity?
   â€¢ Exponential (not a polynomial time algorithm)
  â€¢ Why is this algorithm stupid?
   â€¢ Ignore the wisdom from computing the minimum path for computing other minimum paths


ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ë‹¨ê³„:
ì´ˆê¸°í™”: ì‹œì‘ ì •ì ì—ì„œë¶€í„° ê° ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ë¬´í•œëŒ€ë¡œ ì„¤ì •
ì‹œì‘ ì •ì  ìì‹ ì˜ ìµœë‹¨ ê±°ë¦¬ëŠ” 0ìœ¼ë¡œ ì„¤ì •
ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹œì‘ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì— ë„£ëŠ”ë‹¤.

ë°˜ë³µ (Relaxation): ìš°ì„ ìˆœìœ„ íì—ì„œ ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ì •ì ì„ í•˜ë‚˜ì”© êº¼ë‚¸ë‹¤.
ì´ ì •ì ê³¼ ì¸ì ‘í•œ ê° ì •ì ì— ëŒ€í•´, ì‹œì‘ ì •ì ì„ ê±°ì³ì„œ ê°€ëŠ” ê²½ë¡œê°€ ê¸°ì¡´ì— ì•Œê³  ìˆë˜ ìµœë‹¨ ê±°ë¦¬ë³´ë‹¤ ë” ì§§ìœ¼ë©´ í•´ë‹¹ ê²½ë¡œë¥¼ ì—…ë°ì´íŠ¸í•˜ê³ , ìš°ì„ ìˆœìœ„ íì— ë„£ëŠ”ë‹¤.
ì´ ê³¼ì •ì—ì„œ ìš°ì„ ìˆœìœ„ íëŠ” í•­ìƒ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê°€ì§„ ì •ì ë¶€í„° êº¼ë‚´ ì²˜ë¦¬í•˜ë¯€ë¡œ, ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ë¨¼ì € ì°¾ì•„ê°€ê²Œ ëœë‹¤.


Dijkstraâ€™s Algorithm

â€¢ The distance of a vertex v from a vertex s is the length of a shortest path between s and v
-> ì •ì  vì—ì„œ ì •ì  sê¹Œì§€ì˜ ê±°ë¦¬ëŠ” sì™€ v ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œì˜ ê¸¸ì´
â€¢ Dijkstraâ€™s algorithm computes the distances of all the vertices from a given start vertex s
-> ì£¼ì–´ì§„ ì‹œì‘ ì •ì  sì—ì„œ ëª¨ë“  ë‹¤ë¥¸ ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°
â€¢ Assumptions:
  â€¢ the graph is connected
  â€¢ the edges are undirected //ë¬´ë°©í–¥ ê·¸ë˜
  â€¢ the edge weights are nonnegative // ë¹„ìŒìˆ˜ ê°€ì¤‘
 
â€¢ We grow a â€œcloudâ€ of vertices, beginning with sand eventually covering all the vertices
â€¢ Remember the â€œwisdomâ€ //í•œë²ˆ ê³„ì‚°í•œ ìµœë‹¨ ê²½ë¡œ ì •ë³´ë¥¼ í™œìš©í•˜ì—¬ ë” íš¨ìœ¨ì ìœ¼ë¡œ ë‹¤ìŒ ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì•„ê°„ë‹¤.
ì¦‰, ì´ë¯¸ ê³„ì‚°ëœ ê²½ë¡œë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•ŠëŠ”ë‹¤.
â€¢ Example
  â€¢ What is your distance to â€Obamaâ€ in facebook? 50
  â€¢ Suppose that MoonJaeinbecomes your friend
  â€¢ What is your distance to â€œObamaâ€ then?
  â€¢ Probably much shorter than 50. Maybe 2? 


ì§„í–‰ì„ í•˜ë‹¤ê°€ 
a->b 1
a->c 2
a->d 3
ì¤‘ ì„ íƒ b(ìµœë‹¨ê±°ë¦¬ì´ê¸° ë•Œë¬¸ì—)ë¥¼ í–ˆë‹¤ê³  í•˜ì

b->c 4
b->d 5
b->e 4
b->f 6
ê°€ ìˆì„ ë•Œ ì´ ëª¨ë“  ê²½ìš°ë¥¼ í™•ì¸ í•œ í›„ì— 
a->b
a->c
a->d
ì™€ ë¹„êµí•´ì„œ a ê²½ë¡œì— ë” ì§§ì€ ê²½ë¡œê°€ ìˆëŠ” ê²½ìš° bì—ì„œ ì—°ì†í•´ì„œ ê²½ë¡œë¥¼ ë”°ë¥´ì§€ ì•Šê³  aê²½ë¡œë¥¼ ë”°ë¥¸ë‹¤.
ë’¤ì— ìˆ«ìë¥¼ ê±°ë¦¬ë¼ê³  í•˜ë©´ a->b 1 ë‹¤ìŒì— ì„ íƒë  ê²ƒì€ a->c 2ì¼ ê²ƒì´ë‹¤.


â€¢ We store with each vertex va label d(v) representing the distance of v from s in the subgraph consisting of the cloud and its adjacent vertices
-> ê° ì •ì  vì— ëŒ€í•´ ì‹œì‘ ì •ì  së¡œë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë ˆì´ë¸” d(v)ë¥¼ ì €ì¥ 
â€¢ At each step
  â€¢ We add to the cloud the vertex u outside the cloud with the smallest distance label, d(u) 
  -> í´ë¼ìš°ë“œ ì™¸ë¶€ì—ì„œ í´ë¼ìš°ë“œì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  u ì¤‘ì—ì„œ ê±°ë¦¬ ë ˆì´ë¸” d(u)ê°€ ê°€ì¥ ì‘ì€ ì •ì ì„ ì„ íƒí•˜ì—¬ í´ë¼ìš°ë“œì— ì¶”ê°€
  â€¢ We update the labels of the vertices adjacent to u
  -> ì„ íƒëœ ì •ì  ğ‘¢ ì¸ì ‘ ì •ì ë“¤ì˜ ë ˆì´ë¸” d(v)ë¥¼ ì—…ë°ì´íŠ¸
ì˜ˆë¥¼ ë“¤ì–´, d(v)ë¥¼ d(v)ì™€ d(u)+w(u,v) ì¤‘ ì‘ì€ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸
ì—¬ê¸°ì„œ w(u,v)ëŠ” ì •ì  uì—ì„œ ì •ì  vë¡œ ê°€ëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ì´ë‹¤.
  â€¢ Greedy method: we solve the problem at hand by repeatedly selecting the best choice from among those available in each iteration
  

Edge Relaxation (ê°„ì„ ì˜ ì™„í™”)
â€¢ Consider an edge e = (u,z) such that
â€¢ u is the vertex most recently added to the cloud
â€¢ z is not in the cloud
-> íŠ¹ì • ê°„ì„  e=(u,z)ì— ëŒ€í•´ ì •ì  zì˜ ê±°ë¦¬ d(z)ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê³¼ì •

â€¢ The relaxation of edge e updates distance d(z) as
follows: d(z) <- min{d(z),d(u) + weight(e)}

ì—¬ê¸°ì„œ 
d(z): ì •ì  zì˜ í˜„ì¬ ìµœë‹¨ ê±°ë¦¬ì…ë‹ˆë‹¤.
d(u): ì •ì  uì˜ í˜„ì¬ ìµœë‹¨ ê±°ë¦¬ì…ë‹ˆë‹¤.
weight(e): ê°„ì„  eì˜ ê°€ì¤‘ì¹˜ì…ë‹ˆë‹¤.

ìœ„ì˜ ì—…ë°ì´íŠ¸ëŠ” í´ë¼ìš°ë“œì— ì¶”ê°€ëœ ì •ì  uë¥¼ ê±°ì³ ì •ì  zë¡œ ê°€ëŠ” ê²½ë¡œê°€ ê¸°ì¡´ì˜ zì˜ ìµœë‹¨ ê²½ë¡œë³´ë‹¤ ë” ì§§ì€ ê²½ìš°ì—ë§Œ d(z)ë¥¼ ì—…ë°ì´íŠ¸ í•œë‹¤.


1. ê°„ì„ ì˜ ì™„í™” ê³¼ì •ì—ì„œ uë¥¼ ê³ ë ¤í•˜ëŠ” ê²½ìš°
ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œ íŠ¹ì • ê°„ì„  e=(u,z)ë¥¼ í†µí•´ ì •ì  zì˜ ê±°ë¦¬ d(z)ë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œ uë¥¼ ê³ ë ¤í•˜ëŠ” ê²ƒì˜ ì¤‘ìš”ì„±
(1)í˜„ì¬ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ìœ ì§€: uë¥¼ ê²½ìœ í•´ì„œ ì •ì  zê¹Œì§€ ê°€ëŠ” ê²½ë¡œê°€ ê¸°ì¡´ì˜ zì˜ ìµœë‹¨ ê²½ë¡œë³´ë‹¤ ë” ì§§ì€ ê²½ìš°ì—ë§Œ d(z)ë¥¼ ì—…ë°ì´íŠ¸
ì´ëŠ” í˜„ì¬ê¹Œì§€ ë°œê²¬ëœ ìµœë‹¨ ê²½ë¡œë¥¼ ìœ ì§€í•˜ë©´ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ì•„ê°€ëŠ” ì›ì¹™ì„ ë”°ë¥¸ë‹¤.
(2)í´ë¼ìš°ë“œì˜ í™•ì¥: uê°€ í´ë¼ìš°ë“œì— ì¶”ê°€ëœ ìµœê·¼ì˜ ì •ì ì´ë¯€ë¡œ, ì´ ì •ì ì„ ê²½ìœ í•´ì„œ zê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ì—…ë°ì´íŠ¸í•˜ë©´ì„œ í´ë¼ìš°ë“œê°€ í™•ì¥
ì´ ê³¼ì •ì—ì„œëŠ” uì™€ z ì‚¬ì´ì˜ ìµœë‹¨ ê²½ë¡œê°€ ì ì§„ì ìœ¼ë¡œ ë°œê²¬ë˜ê³  ê°œì„ ëœë‹¤.

2. uë¥¼ ê³ ë ¤í•˜ì§€ ì•ŠëŠ” ê²½ìš°
ë§Œì•½ ê°„ì„ ì˜ ì™„í™” ê³¼ì •ì—ì„œ uë¥¼ ê³ ë ¤í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, zê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ì—…ë°ì´íŠ¸í•  ë•Œ uë¥¼ ê±°ì³ê°€ì§€ ì•Šê³  ì§ì ‘ì ìœ¼ë¡œ ê°€ëŠ” ê²½ë¡œë§Œ ê³ ë ¤
ì´ ê²½ìš°ì—ëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤


Recall: Priority Queue ADT
â€¢ A priority queue stores a collection of entries
â€¢ Typically, an entry is a pair (key, value), where the key indicates the priority
â€¢ Main methods of the Priority Queue ADT
  â€¢ insert(e) : inserts an entry e
  â€¢ removeMin() : removes the entry with smallest key
â€¢ Additional methods
  â€¢ min() : returns, but does not remove, an entry with smallest key
  â€¢ size(), empty()



Dijkstraâ€™s Algorithmì€ ì‹œí—˜ ë²”ìœ„ê°€ ì•„ë‹ˆê¸´ í•œë° shortest í•˜ë ¤ë©´ ì¡°ê¸ˆ ì•Œê³ ìˆê¸´ í•´ì•¼í•´ì„œ í•˜ëŠ” ê²ƒì„
