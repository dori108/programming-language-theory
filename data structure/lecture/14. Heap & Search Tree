Priority Queue : ì¼ë°˜ì ì¸ íì˜ ë°©ì‹ëŒ€ë¡œ ì‘ë™í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ì•„ì´í…œì— í• ë‹¹ëœ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ ì˜ë¯¸
  â€¢ Queue but not first-in-first-out (FIFO)
  â€¢ Rather:
    â€¢ Arbitrary insertion //ë©‹ëŒ€ë¡œ
    â€¢ Priority-based removal
  â€¢ Stores item as key-value pair (k, v)
  â€¢ Key, k: priority of the item (këŠ” ì•„ì´í…œì˜ ìš°ì„ ìˆœìœ„ì´ê³ , vëŠ” ì•„ì´í…œì˜ )
  â€¢ Example: {(5,A), (7,D), (9,C)}
  â€¢ Dequeue â‰¡ Remove_min: Remove the item with the minimum key (5,A)

ì‹œê°„ ë³µì¡ë„ : ğ‘‚(logğ‘›)
ìµœì†Œ í™ì„ ì‚¬ìš©í•˜ì—¬ ìš°ì„ ìˆœìœ„ íë¥¼ ê´€ë¦¬í•˜ë¯€ë¡œ, insertì™€ remove_min ì—°ì‚°ì˜ ì‹œê°„ë³µì¡ë„ëŠ” ìœ„ì™€ ê°™ë‹¤.

Priority Queue: Operation Example
ì†ìœ¼ë¡œ ì—°ìŠµí•¨


Binary Heap
ìš°ì„ ìˆœìœ„ íë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•œ íš¨ìœ¨ì ì¸ ìë£Œêµ¬ì¡°ë¡œ ë‘ê°€ì§€ ì†ì„±ì´ ìˆë‹¤.
â€¢ An efficient structure to implement priority queue
â€¢ Properties:
  â€¢ Complete binary tree property : ì™„ì „ ì´ì§„íŠ¸ë¦¬ ì†ì„±
  ì´ëŠ” íŠ¸ë¦¬ì˜ ëª¨ë“  ë ˆë²¨ì´ ê½‰ ì°¨ ìˆìœ¼ë©°, ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ë…¸ë“œë“¤ì€ ì™¼ìª½ë¶€í„° ì±„ì›Œì§„ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸
  í¬í™” ì´ì§„ íŠ¸ë¦¬(Full Binary Tree)ëŠ” ë‹¤ë¦„
  â€¢ Heap-order property: key of any node >= key of its parent : í™-ìˆœì„œ ì†ì„±
  ìµœì†Œ í™ì˜ ê²½ìš°, ë¶€ëª¨ ë…¸ë“œì˜ í‚¤ëŠ” í•­ìƒ ìì‹ ë…¸ë“œì˜ í‚¤ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤.
  ìµœëŒ€ í™ì˜ ê²½ìš°, ë¶€ëª¨ ë…¸ë“œì˜ í‚¤ëŠ” í•­ìƒ ìì‹ ë…¸ë“œì˜ í‚¤ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤.
  ì—¬ê¸°ì„œëŠ” ìµœì†Œ í™ì„ ê¸°ì¤€ìœ¼ë¡œ ì–˜ê¸°í•˜ëŠ” ê²ƒ ê°™ë‹¤.


Heap: Insertion
â€¢ add(k, v): insert key-value pair (k, v)
í™ì—ì„œì˜ ì‚½ì… ì—°ì‚°ì€ í‚¤-ê°’ ìŒ (k, v)ë¥¼ í™ì— ì¶”ê°€í•˜ëŠ” ê³¼ì •
â€¢ Insert at the rightmost position q of the last level
â€¢ to maintain the complete binary tree property
ìƒˆ ìš”ì†Œë¥¼ ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ê°€ì¥ ì˜¤ë¥¸ìª½ ìœ„ì¹˜ì— ì‚½ì…í•œë‹¤. ì´ë¥¼ í†µí•´ ì™„ì „ ì´ì§„ íŠ¸ë¦¬ ì†ì„±ì„ ìœ ì§€
â€¢ Perform up-heap bubbling
â€¢ To maintain the heap-order property
ì‚½ì…ëœ ìš”ì†Œê°€ í™-ìˆœì„œ ì†ì„±ì„ ìœ„ë°˜í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, up-heap bubbling ê³¼ì •ì„ ìˆ˜í–‰í•˜ì—¬ ì´ ì†ì„±ì„ ë³µêµ¬
â€¢ Continue to swap with the parent node until k >= key(parent)
ì‚½ì…ëœ ìš”ì†Œë¥¼ ë¶€ëª¨ì™€ ë¹„êµí•˜ì—¬ í•„ìš”ì‹œ êµí™˜
â€¢ Worst-case running time: O(logn)

ì™„ì „ì´ì§„íŠ¸ë¦¬ ì†ì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ì„œ ë¦¬í”„ì˜ ê°€ì¥ ì˜¤ë¥¸ìª½ ë…¸ë“œì˜ ì™¼ ìœ„ì¹˜ì— ìƒˆë¡œ ì‚½ì…í•œë‹¤.
ê·¸ëŸ¬ë©´ ì™„ì „ì´ì§„íŠ¸ë¦¬ ì†ì„±ì´ ê¹¨ì§€ì§€ ì•ŠëŠ”ë‹¤.


Heap: min-key deletetion

â€¢ remove_min(): removes the root node
ë£¨íŠ¸ ë…¸ë“œëŠ” ìµœì†Œ í‚¤ë¥¼ ê°€ì§€ë¯€ë¡œ í™ì˜ ìµœìƒë‹¨ì— ìœ„ì¹˜ -> ì´ ë…¸ë“œë¥¼ ì œê±°í•´ì„œ ë°˜í™˜í•´ì•¼í•œë‹¤.
â€¢ To maintain the complete binary tree property:
  â€¢ Remove the node at the last position (rightmost position of the last level) and copy it to the root (replacing the original root-item)
  â€¢ Say: the new root is: (k, v)
ë™ì‹œì— ì™„ì „ì´ì§„íŠ¸ë¦¬ ì†ì„±ì€ ìœ ì§€í•´ì•¼í•œë‹¤.
íŠ¸ë¦¬ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ìˆëŠ” ë…¸ë“œë¥¼ ì œê±°í•˜ê³  (ê°€ì¥ ì˜¤ë¥¸ìª½ì˜ ë…¸ë“œì˜ ì™¼ìª½ì— ìœ„ì¹˜)
ì´ ë…¸ë“œë¥¼ ë£¨íŠ¸ ìœ„ì¹˜ì— ë³µì‚¬í•œë‹¤.
â€¢ Perform down-heap bubbling : ìƒˆë¡œìš´ ë£¨íŠ¸ ë…¸ë“œë¥¼ ìì‹ ë…¸ë“œì™€ ë¹„êµí•˜ì—¬ í•„ìš”ì‹œ êµí™˜í•œë‹¤.
  â€¢ to maintain the heap-order property
  â€¢ Continue to swap with the minimal-key-child until k <= key(minimal-key-child)
â€¢ Worst-case running-time: O(logn)
ë¹„êµí•  ë•Œ (rootë¥¼ ê°ˆì•„ë¼ìš°ê³  ë‚´ë ¤ì˜¬ ë•Œ) ì™¼,ì˜¤ë¥¸ìª½ì„ ë¹„êµí•´ì„œ ë” ì‘ì€ ìª½ì˜ ë…¸ë“œë‘ switchí•œë‹¤.

Heap Bubblingì˜ ì¢…ë¥˜

ì—…í™ ë²„ë¸”ë§(Up-Heap Bubbling):

ìƒˆë¡œìš´ ë…¸ë“œë¥¼ í™ì— ì‚½ì…í•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
ìƒˆë¡œìš´ ë…¸ë“œëŠ” í™ì˜ ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ì¶”ê°€ëœ í›„, ê·¸ ë…¸ë“œê°€ í™ ì†ì„±ì„ ë§Œì¡±í•  ë•Œê¹Œì§€ ë¶€ëª¨ ë…¸ë“œë“¤ê³¼ ë¹„êµí•˜ë©° ìœ„ë¡œ ì´ë™í•©ë‹ˆë‹¤.
ì´ ê³¼ì •ì€ ì‚½ì…ëœ ë…¸ë“œê°€ ë¶€ëª¨ë³´ë‹¤ ì‘ì„ ë•Œê¹Œì§€ ë°˜ë³µë©ë‹ˆë‹¤.

ë‹¤ìš´í™ ë²„ë¸”ë§(Down-Heap Bubbling):

ë£¨íŠ¸ ë…¸ë“œë¥¼ ì‚­ì œí•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
ë§ˆì§€ë§‰ ìœ„ì¹˜ì— ìˆëŠ” ë…¸ë“œë¥¼ ë£¨íŠ¸ ìœ„ì¹˜ë¡œ ì´ë™ì‹œí‚¨ í›„, ê·¸ ë…¸ë“œê°€ í™ ì†ì„±ì„ ë§Œì¡±í•  ë•Œê¹Œì§€ ìì‹ ë…¸ë“œë“¤ê³¼ ë¹„êµí•˜ë©° ì•„ë˜ë¡œ ì´ë™í•©ë‹ˆë‹¤.
ì´ ê³¼ì •ì€ ì´ë™ëœ ë…¸ë“œê°€ ìì‹ ë…¸ë“œë“¤ë³´ë‹¤ í´ ë•Œê¹Œì§€ ë°˜ë³µë©ë‹ˆë‹¤.

ì‹œê°„ ë³µì¡ë„ : O(logn)


Binary Search Tree (BST)
â€¢ a binary tree with each node storing a key-value pair (k, v) such that:
  â€¢ Keys of its left subtree are < k
  â€¢ Keys of its right subtree are > k
  
BST: Search
â€¢ search(root, k): searches the node storing key k.
  â€¢ if k == root.key:
     â€¢ return root
  â€¢ elif k < root.key and left subtree exists
    â€¢ return search(root.left, k)
  â€¢ elif k > root.key and right subtree exists
    â€¢ return search(root.right, k)
  â€¢ Else:
    â€¢ return None(unsuccessful search)

BST: Search parent also
â€¢ search_p(root, k): finds the node with key k and its parent
â€¢ Similar process but use loop instead of recursion
â€¢ Initialize:
  â€¢ node=parent=root
â€¢ Loop:
  â€¢ If node is None: Break
  â€¢ If k==node.key: Break
  â€¢ parent=node
  â€¢ If k<node.key and left subtree exists: node=node.left
  â€¢ If k>node.key and right subtree exists: node=node.right
  â€¢ Return node, parent


BST: Insertion
â€¢ insert(root, k, v): inserts the key-value pair (k,v)
â€¢ Insertion process:
  â€¢ node, p = search_p(root, k, v)
ì£¼ì–´ì§„ í‚¤ë¥¼ ì°¾ê±°ë‚˜ ì ì ˆí•œ ì‚½ì… ìœ„ì¹˜ë¥¼ ì°¾ëŠ”ë‹¤.
íŠ¸ë¦¬ íƒìƒ‰ -> ì£¼ì–´ì§„ í‚¤ê°€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  â€¢ if k==node.key: # key already exists
    â€¢ Update node.value to v
ì¡´ì¬í•˜ë©´ ë°”ë¡œ ë°˜í™˜ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ë°‘ì˜ í”„ë¡œì„¸ìŠ¤ì— ë”°ë¼ ì ì ˆí•œ ìœ„ì¹˜ì— ì§‘ì–´ ë„£ëŠ”ë‹¤.
  â€¢ if k<p.key:
    â€¢ Insert (k,v) to the left of p
  â€¢ if k>p.key:
    â€¢ Insert (k,v) to the right of p


BST: Deletion

â€¢ delete(root, k): removes the node storing key k
â€¢ Search the node and its parent p using search_p
â€¢ Deleting node is not as simple as insertion
  â€¢ Insertion: always done as leaf nodes
  â€¢ Deletion: can be for any nodes
â€¢ Two scenario:
  â€¢ node has atmost (â‰¤) one child
  â€¢ node has two children

  â€¢ Case-I: node has atmost (â‰¤) one child
    â€¢ Delete node and link its child to the parent
    (i.e, bring the child in nodeâ€™s position)
  â€¢ Note: this case also generalizes the no-child case
  
  â€¢ Case-II: node has both left and right child
    â€¢ To delete and replace node,
    â€¢ bring the largest-key-node from the left-subtree
    â€¢ Or, the smallest-key-node from the right-subtree


Running Time
â€¢ Depends on tree height
â€¢ Best-case height: log(n)
â€¢ Worst-case height: n
